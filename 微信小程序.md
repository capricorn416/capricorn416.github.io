# 微信小程序

## 一、准备

### （一） 移动端相关知识

#### 1. 物理像素

- 屏幕的分辨率
- 设备能控制显示的最小单元，可以把物理像素看成是对应的像素点

#### 2. 设备独立像素＆css像素

- 设备独立像素（也叫密度无关像素），可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素，然后由相关系统转换为物理像素

#### 3. dpr比 & DPI & PPI

- dpr：设备像素比，物理像素/设备独立像素 = dpr，一般以iphone6的dpr为准，dpr=2

### （二） 移动端适配方案

#### 1. viewport适配

- 为什么做viewport适配

  - 手机厂商在生产手机的时候大部分手机默认页面宽度为980px
  - 手机实际视口宽度都要小于980px，如：iphone6为375px
  - 开发需求：需要将980的页面完全显示在手机屏幕上且没有滚动条

- 实现：

  ```<meta name="viewport" content="width=device-width,initial-scale=1.0">```

#### 2. rem适配

+ 为什么做rem适配

  - 机型太多，不同的机型屏幕大小不一样
  - 需求：一套设计稿的内容在不同的机型上呈现的效果一致，根据屏幕大小不同的变化，页面中的内容也相应变化

+ 实现

  ```js
  function remRefresh() {
      let clientWidth = document.documentElement.clientWidth;
      // 将屏幕等分10份 
      let rem = clientWidth / 10;
      document.documentElement.style.fontSize = rem + 'px';
      document.body.style.fontSize = '12px';
  }
  
  window.addEventListener('pageshow', () => { remRefresh() })
  
  // 函数防抖
  let timeoutId;
  window.addEventListener('resize', () => {
      timeoutId && clearTimeout(timeoutId);
      timeoutId = setTimeout(() =>{ remRefresh() }, 300)
  })
  ```

+ 第三方库实现
  - lib-flexible + px2rem-loader

## 二、小程序特点

### （一） 概述

#### 1. 特点

+ 没有DOM
+ 组件化开发 ： 具备特定功能效果的代码集合
  - 页面包含组件
+ 体积小 ，单个压缩包体积不能大于2M，否则无法上线
+ 小程序的四个重要文件
  - *.js
  - *.wxml --- ---> view结构 ---- > html
  - *.wxss --- ---> view样式 ----- > css
  - *. json ---- > view 数据 ---------- > json文件

#### 2. 小程序适配方案

+ 小程序适配单位：rpx （responsive pixel响应式像素单位）
+ 规定任何屏幕下宽度为750rpx
+ 小程序会根据屏幕的宽度不同自动计算 rpx值的大小
+ iphone6下：1rpx = 1物理像素 = 0.5px

![image-20211217190148863](C:\Users\ThinkPad\AppData\Roaming\Typora\typora-user-images\image-20211217190148863.png)

### （二） 小程序配置

#### 1. sitemap 配置

+ `sitemap.json`用于配置小程序及其页面是否允许被微信索引（爬取页面）

#### 2. 全局配置

+ `app.json`
  - 用于为整个应用进行选项设置

#### 3. 页面配置

+ `页面名称.json`

  - 用于为指定的页面进行配置

  + 页面配置的优先级高于全局配置

### （三） 基本搭建

+ `app.json`

  ```json
  {
    "pages": []
  }
  ```
  
+ `app.js`

  ```js
  // 注册小程序应用
  // App()必须在app.js中调用，必须调用且只能调用一次
  App({})
  ```

+ `app.wxss`

  ```css
  /* 全局公共样式 */
  page {
      height: 100%;
  }
  ```

+ `pages`

  - `index`
    - `index.wxml`

    - `index.wxss`

    - `index.js`

      ```js
      // 获取应用实例
      const app = getApp()
      // 注册当前页面的实例
      Page({})
      ```

      

    - `index.json`

## 三、wxml语法

+ `<view>`：块级元素
+ `<text>`：内联元素

 ### （一） 数据绑定

#### 1. 初始化数据

+ 页面.js的data选项中

  ```js
  Page({
    data: {
  	message: '初始化测试数据'
    }
  })
  ```

#### 2. 使用数据

+ `{{ message }}`
+ `this.data.message`
+ 小程序中为**单项数据流** model ---> view

#### 3. 修改数据

+ ```js
  // this代表当前页面的实例对象
  this.setData({message: '修改之后的数据'})
  ```

  - 修改数据的行为始终是同步的（自身钩子函数/定时器函数）
  
+ #### *Vue2数据劫持代理*

  ```js
  // 模拟Vue中data选项
  let data = {
      username: 'curry',
      age: 33
  }
  
  // 模拟组件的实例
  let _this = { 
      // test: '测试'
  }
  
  // 利用Object.defineProperty()
  for(let item in data) {
      Object.defineProperty(_this, item, {
          // get：用来获取扩展属性值的，当获取该属性值的时候调用get方法
          get() {
              // console.log('get()')
              return data[item]
          },
          // set：监视扩展属性的，只要一修改就调用
          set(newValue) {
              // console.log('set()', newValue)
              // _this.username = newValue 不要在set方法中直接修改当前扩展属性的值，会出现死循环
              data[item] = newValue
          }
      })
  }
  console.log(_this)	// 扩展属性需要展开才能看到，(...)是通过get获取到的value值
  // 通过Object.defineProperty的get方法添加的扩展属性不能直接对象.属性修改
  _this.username = 'wade'
  console.log(_this.username)
  ```

### （二） 事件绑定

#### 0. 扩展内容

+ 事件流的三个阶段
  - 捕获：从外到内
  - 执行目标阶段
  - 冒泡：从内向外

#### 1. 事件分类

+ 冒泡事件
  - 当一个组件上的事件被触发后，该事件会向父节点传递。
+ 非冒泡事件
  - 当一个组件上的事件被触发后，该事件不会向父节点传递。
  - 表单事件和自定义事件通常是非冒泡事件。

#### 2. 绑定事件

+ bind绑定：事件绑定不会阻止冒泡事件向上冒泡。
+ catch绑定：事件绑定可以阻止冒泡事件向上冒泡。

#### 3. 事件委托

+ 将子元素的事件委托（绑定）给父元素
+ 好处
  - 减少绑定的次数
  - 后期新添加的元素也可以享用之前委托的事件
+ 原理
  - 冒泡
+ 触发事件的是子元素
+ 通过event.target找到触发事件的对象

#### 4. currentTarget VS target

+ currentTarget要求绑定事件的元素一定是触发事件的元素
+ target绑定事件的元素不一定是触发事件的元素
  - 通过id向event传参的时候如果传的是number会自动转换成string
  - 通过data-传参不会转换

```js
  handleInput(e) {
    // let type = e.currentTarget.id;  // id传值
    let type = e.currentTarget.dataset.type;  // data-key=value
    this.setData({
      [type]: e.detail.value
    })
  }
```

#### 5. 定义事件相关

+ 分类

  - 标准DOM事件
  - 自定义事件

+ 标准DOM事件

  - 例如click, input...

  - 事件名固定的，事件由浏览器触发

+ 自定义事件

  - 绑定事件
    - 事件名
    - 事件的回调
    - 订阅方：接受数据的一方
  - 触发事件
    - 事件名
    - 提供事件参数对象，等同于原生事件的event对象
    - 发布方：提供数据的一方
  - **先订阅再发布**

### （三） 条件渲染

#### 1. 语法说明

+ `wx:if=""`
+ `wx:elif=""`
+ `wx:else`

### （四） 列表渲染

#### 1. 语法说明

+ `wx:for=’{{array}}’`
  - 默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`
    - 使用 `wx:for-item` 可以指定数组当前元素的变量名
    - 使用 `wx:for-index` 可以指定数组当前下标的变量名
  
+ `wx:key=’唯一值’`

  - 没有合适的key

    ```js
    let index = 0
    let recordList = recordListData.splice(0, 10).map(item => {
      item.id = index++
      return item
    })
    ```

    

### （五） 生命周期

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png)

+ `onLoad`：监听页面加载
+ `onReady`：监听页面初次渲染完成
+ `onShow`：监听页面显示（执行多次）
+ `onHide`：监听页面隐藏
+ `onUnload`：监听页面卸载

### （六）转发分享

+ 监听用户点击页面内转发按钮（button组件 `open-type="share"`）或右上角菜单“转发”按钮的行为
+ 只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮

```js
onShareAppMessage: function({from}) {
  return {
      title: '',
      path: '',
      imageUrl: ''
  }
}
```

### （七） 小程序APP

#### 1. App

```js
// app.js
App({
  globalData: {}
})
```

#### 2. getApp

```js
const appInstance = getApp()
Page({
  // appInstance.globalData.xxx
})
```

### （八） 模板使用

#### 1. 定义模板

+ 使用 name 属性，作为模板的名字，然后在`<template>`内定义代码片段

+ `myTemplate.wxml`

  ```html
  <template name="myTmp">
    <view>{{username}}</view>
    <view>{{age}}</view>
  </template>
  ```

+ `myTemplate.wxss`

#### 2. 使用模板

+ 使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入

  ```html
  <import src="/template/myTemplate/myTemplate.wxml"/>
  <template is="myTmp" data="{{...person}}"></template>
  ```

  ```css
  @import "/template/myTemplate/myTemplate.wxss"
  /* 模板的样式可以被后续覆盖 */
  ```

  ```js
  data: {
    person: {
      username: '',
      age: 
    }
  }
  ```

## 四、 小程序API

### （一）路由跳转

+ 小程序里全局对象是`wx`
+ 小程序环境里没有`window`

#### 1. `wx.navigateTo()`

+ **保留**当前页面，跳转到应用内的某个页面

  ```js
  wx.navigateTo({
  	url: '/pages/logs/logs',
  })
  ```
  
+ 不能跳转到tabbar页面

#### 2. `wx.redirectTo()`

+ **关闭**当前页面，跳转到应用内的某个页面
+ 不能跳转到tabbar页面

#### 3. `wx.reLaunch()`

+ **关闭所有**页面，打开到应用内的某个页面

#### 4. 路由跳转传参

- query参数

  ```html
  <view data-song="{{item}}" bindtap="toSongDetail"></view>
  ```

  ```js
  toSongDetail(e) {
    let song = e.currentTarget.dataset.song	// 对象
    wx.navigateTo({
      url: '/pages/songDetail/songDetail?song=' + JSON.stringify(song)
    })
  }
  ```

  ```js
  onLoad: function (options) {
    // options：用于接收路由跳转的query参数
    // 原生小程序中路由传参，对参数的长度有限制，如果参数长度过长会自动截取掉
    console.log(JSON.parse(options.song))
  }
  ```

  

### （二） 获取用户信息

#### 1. `wx.getUserProfile()`

+ 会弹出授权框

+ 只能使用 catchtap 或者 bindtap 进行调用

  ```js
  wx.getUserProfile({
  	desc: '', // 不写不弹提示框
  	success: (res) => {}
  })
  ```

### （三） 网络

#### 1. 请求

+ `wx.request()`
+ 注意点：
  - 协议必须是https协议
  - 一个接口最多配置20个域名
  - 并发限制上限是10个
  - 开发过程中可以设置不校验合法域名：开发工具 -> 详情 -> 本地设置

### （四） 数据缓存

#### 1. 存入数据

+ `wx.setStorageSync()`
+ `wx.setStorage()`
  - 建议存储的数据为json数据
  - 单个key允许存储的最大数据长度为1MB，所有数据存储上限为10MB
  - 属于永久存储，同H5的localStorage一样

#### 2. 读取数据

+ `wx.getStorageSync()`
+ `wx.setStorage()`

#### 3. 删除数据

#### 4. 清空数据

### （五） 获取用户唯一标识（openID）

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg)

#### 1. 获取登录凭证

#### 2. 将登录凭证发送服务器

```js
wx.login({
  success: async (res) => {
    let code = res.code
    let result = await ('/getOpenId', {code})
  }
})
```

#### 



## 五、组件

### （一） 表单组件

#### 1. button

+ `open-type`：微信开放能力
  - `getUserInfo`：获取用户信息，从`bindgetuserinfo`回调中获取到用户信息 
    - 不会弹出授权框

### （二） 视图容器

#### 1. scroll-view

+ 下拉刷新
  - `refresher-enabled`
  - `bindrefresherrefresh="handleRefresher"`
  - `refresher-triggered="{{isTriggered}}"`
+ 上拉触底
  - `bindscrolltolower="handleToLower"`

### （三） 自定义组件



## 六、 使用npm包

### （一） 步骤

#### 1. 初始化package.json

+ `npm init` 或 `npm init -y`

#### 2. 勾选允许使用npm

#### 3. 下载npm包

+ `npm install xxx`

#### 4. 构建npm

+ 开发工具——工具——构建npm
  + 会将 node_modules 中的包打包到 miniprogram_npm 中



## 七、 分包

### （一） 常规流程

#### 1. 特点

+ 加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容
+ 分包的页面可以访问主包的文件，数据，图片等资源
+ 主包
  - 主包来源：除了分包以外的内容都会被打包到主包中
  - 通常放置启动页/tabBar页面

### （二） 独立分包

#### 1. 配置

+ 设置 independent 为 true

#### 2. 特点

+ 独立分包可单独访问分包的内容，不需要下载主包
+ 独立分包不能依赖主包或者其他包的内容

#### 3. 使用场景

+ 通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包
  - 如：临时加的广告页/活动页

### （三） 分包预下载

#### 1. 配置

+ app.json 中设置 preloadRule 选项
+ key(页面路径): { packages: [ 预下载的包名 || 预下载的包的根路径 ] }

#### 2. 特点

+ 在加载当前包的时候可以设置预下载其他的包
+ 缩短用户等待时间，提高用户体验



## 八、 实战开发

### （一） css相关

#### 1. 文本溢出隐藏 省略号代替

+ 单行

  ```css
  white-space: nowrap;
  overflow: hidden;	/* 对块级元素生效 */
  text-overflow: ellipsis;
  ```

+ 多行

  - 只对汉字生效

  ```css
  display: -webkit-box;
  overflow: hidden; 
  text-overflow: ellipsis;
  -webkit-box-orient: vertical;	/* 设置对齐模式 */
  -webkit-line-clamp: 2;	/* 设置多行的行数 */
  ```

#### 2. flex布局

+ 当一个元素设置为flex，其子元素会自动成为block元素

#### 3. 水平垂直居中

- 子元素在父元素内水平垂直居中

  ```css
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
  ```

  

### （二） js相关

#### 1. 封装请求功能函数

+ `utils`文件夹下

  + `request.js`

    ```js
    import config from './config'
    export default (url, data={}, method='GET') => {
      return new Promise((resolve, reject) => {
        // 1. new Promise初始化promise实例的状态为pending
        wx.request({
          url: config.host + url,
          data,
          method,
          header: {
          	cookie: wx.getStorageSync('cookies') ? 
              wx.getStorageSync('cookies').join('') : '' 
          },
          success: (res) => {
            if(data.isLogin) {
              wx.setStorageSync('cookies', res.cookies)
            }
            resolve(res.data)	// resolve修改promise的状态为成功状态resolved
          },
          fail: (err) => {
            reject(err)	// reject修改promise的状态为失败状态rejected
          }
        })
      })
    }
    ```
  
    + 调用
  
    ```js
    import request from '../../utils/request'
    Page({
      // onLoad: function (options) {
      //   request('http://localhost:3000/banner', {type: 2}).then((res)=> {
      //     console.log(res);
      //   })
      // }
        
      // 需要勾选增强编译
      onLoad: async function (options) {
        let results = await request('http://localhost:3000/banner', {type: 2})
        console.log(results);
      },
    })
    ```
  
  + `config.js`
  
    ```js
    // 配置服务器相关信息
    export default {
      host: 'http://localhost:3000'
    }
    ```


#### 2. 数组方法

+ `splice`：会修改原数组，可以对指定的数组进行增删改
+ `slice`：不会修改原数组

#### 3. 手指移动

+ 三件套：

  - `bindtouchstart=""`
  - `bindtouchmove=""`
  - `bindtouchend=""`

+ js

  ```js
  let startY = 0  //  起始的坐标
  let moveY = 0 // 移动的坐标
  let moveDistance = 0  // 移动的距离
  
    handleTouchStart(event) {
      // 获取手指起始坐标
      startY = event.touches[0].clientY
    },
        
    handleTouchMove(event) {
      moveY = event.touches[0].clientY
      moveDistance = moveY - startY
      // todo
    },
        
    handleTouchEnd() {
  	// todo
    },
  ```


#### 4. 控制视频播放

+ 需求
  - 在点击播放的事件中需要找到上一个播放的视频
  - 在播放新的视频之前关闭上一个正在播放的视频
+ 关键
  - 如何找到上一个视频的实例对象
  - 如何确认点击播放的视频和正在播放的视频不是同一个视频
+ 单例模式
  - 需要创建多个对象的场景下，通过一个变量接收，始终保持只有一个对象
  - 节省内存空间

```js
if(e.target.id === this.data.lastId) return
let videoContext = wx.createVideoContext(this.data.lastId)
videoContext.stop()
let vid = e.currentTarget.id
  this.setData({
    lastId: vid
  })
```

```js
let vid = e.currentTarget.id
this.vid !== vid && this.videoContext && this.videoContext.stop()
this.vid = vid
this.videoContext = wx.createVideoContext(vid)
```

#### 5. 监听视频播放进度

+ 判断记录播放时长的videoUpdateTime数组中是否有当前视频的播放记录
  - 如果有，在原有的播放记录中修改播放时间为当前的播放时间
  - 如果没有，需要在数组中添加当前视频的播放对象

```js
// bindtimeupdate="handleTimeUpdate"
let videoTimeObj = {
  vid: e.currentTarget.id,
  currentTime: e.detail.currentTime
}
let {videoUpdateTime} = this.data
let videoItem = videoUpdateTime.find(item => item.vid === videoTimeObj.vid)
if(videoItem) {	// 之前有
  videoItem.currentTime = videoTimeObj.currentTime
} else {	// 之前没有
  videoUpdateTime.push(videoTimeObj)
}
// 更新videoUpdateTime
this.setData({
  videoUpdateTime
})
```

+ 视频播放结束时移除记录播放时长数组中当前视频的对象

```js
// bindended="handleEnded"
let {videoUpdateTime} = this.data
videoUpdateTime.splice(videoUpdateTime.findIndex(item => item.vid === e.currentTarget.id) , 1)
this.setData({
  videoUpdateTime
})
```

#### 6. 防抖和节流

+ 节流

  ```js
  let isSend = false
  handle() {
    if(isSend) return
    isSend = true
    this.getSearchList()
    setTimeout(() => {
      isSend = false
    }, 300)
  }
  ```

+ 防抖

  ```js
  let timer = null
  handle(e) {
    if(timer) clearTimeout(timer)
    timer = setTimeout(() => {
      this.getSearchList()
    }, 300) 
  }
  ```

  
