## Emmet语法——HTML
1. 生成标签：直接输入标签名，按tab键即可
2. 如果想要生成多个相同标签，加上`*` 就可以了。比如div*3
3. 如果有父子级关系的标签，可以用`>`。比如ul>li
4. 如果有兄弟关系的标签，用`+`就可以了。比如div+p
5. 如果生成带有类名或者id的，直接写`.demo`或者`#demo`，tab键就可以了
6. 如果生成的div类名是有顺序的，可以用自增符号`$`

# CSS3
## 一、CSS简介
### 1. CSS语法规范
+ CSS规则由两个主要的部分构成：选择器以及一条或多条声明
### 2. CSS代码风格
+ 空格规范
  - 属性值前面，冒号后面，保留一个空格
  - 选择器（标签）和大括号中间保留空格
### 3. CSS属性书写顺序
+ 布局定位属性：display/position/float/clear/visibility/overflow
+ 自身属性：width/height/margin/padding/border/background
+ 文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word
+ 其他属性：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient

## 二、CSS选择器
### 1. 基础选择器
+ 标签选择器
+ 类选择器
  - 多类名：多个类名中间用空格分开
+ id选择器
+ 通配符选择器
  - `*`，表示选取页面中所有元素（标签）
### 2. 复合选择器
+ 后代选择器/包含选择器
  - `元素1 元素2 {}`
  - 元素1和元素2中间用空格隔开
  - 元素1是父级，元素2是子级，最终选择的是元素2
  - 元素2可以是儿子，也可以是孙子等，只要是元素1的后代即可
  - 元素1和元素2可以是任意基础选择器
+ 子选择器
  - 只能选择作为某元素的最近一级子元素（**亲儿子**元素）
  - `元素1>元素2 {}`
+ 并集选择器
  - 选择多组标签，同时为他们定义相同的样式
  - `元素1,元素2 {}`
+ 伪类选择器
  - 用于向某些选择器添加特殊的效果
  - 链接伪类选择器
    * `a:link`：选择所有未被访问的链接
    * `a:visited`：选择所有已被访问的链接
    * `a:hover`：选择鼠标指针位于其上的链接
    * `a:active`：选择活动链接（鼠标按下未弹起的链接）
    * 为了确保生效，请按照**LVHA**的顺序声明
  - :focus伪类选择器
    * 用于选取获得焦点的表单元素
    * `input:focus {}`
## 三、CSS引入方式
+ 行内样式表（行内式）
  - style其实就是标签的属性
  - 在**双引号**中间，写法要符合CSS规范
+ 内部样式表（嵌入式）
  - <style>标签理论上可以放在HTML文档的任何地方，但一般会放在文档的<head>标签中
+ 外部样式表（链接式）
  - ```<link rel='stylesheet' href=''>```
## 四、字体属性
+ `font-family`：字体系列
+ `font-size`：字体大小
  - 谷歌浏览器默认字体大小为16px
+ `font-weight`：字体粗细
  - 400 = normal
  - 700 = bold
+ `font-style`：文字样式
  - normal
  - italic（斜体）
+ 复合属性
  - ```font: font-style font-weight font-size/line-height font-family;```
  - 不需要设置的属性可以省略（取默认值），但必须保留**font-size**和**font-family**属性，否则font属性将不起作用
## 五、文本属性
+ `color`：文本颜色
  - 开发中最常用的是十六进制
+ `text-align`：对齐文本
  - 用于设置元素内文本内容的**水平**对齐方式
  - left（左对齐）
  - right（右对齐）
  - center（居中对齐）
+ `text-decoration`：装饰文本
  - none
  - underline
  - overline（上划线）
  - line-through（删除线）
+ `text-indent`：文本缩进
  - 用来指定文本的第一行的缩进，通常是将段落的首行缩进
  - 2em => em是一个相对单位，就是当前元素一个文字的大小，如果当前元素没有设置大小，则会按照父元素的一个文字大小
+ `line-height`：行间距（行高）
  - 行间距（行高） = 上间距+文本高度+下间距
  - 单行文字垂直居中：让文字的行高等于盒子的高度
  - 行高小于盒子高度，文字会偏上；行高大于盒子高度，文字会偏下
## 六、元素显示模式
+ 元素显示模式就是元素（标签）以什么方式进行显示
+ HTML元素一般分为块元素和行内元素两类
### 1. 块元素
  + 常见的块元素有\<h1>~\<h6>、\<p>、\<div>、\<ul>、\<ol>、\<li>等
  + 块元素的特点：
    - 自己独占一行
    - 高度、宽度、外边距以及内边距都可以控制
    - 宽度默认是容器（父级宽度）的100%
    - 是一个容器或盒子，里面可以放行内或者块级元素
  + 注意：
    - 文字类的元素内不能使用块级元素
### 2. 行内元素/内联元素
  + 常见的行内元素有\<a>、\<strong>、\<b>、\<em>、\<i>、\<del>、\<s>、\<ins>、\<u>、\<span>等
  + 行内元素的特点：
    - 相邻行内元素在一行上，一行可以显示多个
    - 高、宽直接设置是无效的
    - 默认宽度就是它本身内容的宽度
    - 行内元素只能容纳文本或其他行内元素
  + 注意：
    - 链接里面不能再放链接
    - 特殊情况链接\<a>里面可以放块级元素，但是给\<a>转换一下块级模式最安全
### 3. 行内块元素
  + 在行内元素中有几个特殊的标签\<img>、\<input>、\<td>，它们同时具有块元素和行内元素的特点
  + 行内块元素的特点：
    - 和相邻行内元素（行内块）在一行上，但是它们之间会有空白缝隙。一行可以显示多个
    - 默认宽度就是它本身内容的
    - 高度、行高、外边距以及内边距都可以控制
### 4. 元素显示模式转换
  + 一个模式的元素需要另外一个模式的特性
  + 转换为块元素：`display: block;`
  + 转换为行内元素：`display: inline;`
  + 转换为行内块：`display: inline-block;`
## 七、背景
  + `background-color`：背景颜色
    - transparent（默认）
    - color
  + `background-image`：背景图片
    - 常见于logo或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置
    - none
    - url()
  + `background-repeat`：背景平铺
    - repeat（默认）
    - no-repeat
    - repeat-x
    - repeat-y
  + `background-position`：背景图片位置
    - `background-positon: x y;`
    - x坐标和y坐标可以使用方位名词或者精确单位
    - 参数是方位名词
      * 如果指定的两个值都是方位名词，则两个值前后顺序无关
      * 如果只指定了一个方位名词，另一个省略，则第二个值默认居中对齐
    - 参数是精确单位
      * 如果只指定一个数值，那该数值一定是x坐标，另一个默认垂直居中
    - 参数是混合单位
  + `background-attachment`：背景图像固定（背景附着）
    - 设置背景图像是否固定或者随着页面的其余部分滚动
    - 后期可以制作视差滚动的效果
    - scroll（默认）
    - fixed
  + 背景属性复合写法
    - `background:`没有特定的书写顺序，一般习惯约定顺序为：**背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置**
  + `background: rgba(0, 0, 0, 0.3);`：背景色半透明
    - 最后一个参数是alpha透明度，取值范围在0~1之间
    - 背景半透明是指盒子背景半透明，盒子里面的内容不受影响
## 八、CSS的三大特性
### 1. 层叠性
  + 相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题
  + 样式冲突，遵循的是就近原则，哪个样式离结构近，就执行哪个样式
  + 样式不冲突，不会层叠
### 2. 继承性
  + 子标签会继承父标签的某些样式（text-, font-, line-这些元素开头的可以继承，以及color属性）
  + 行高的继承性
    - 行高可以跟单位也可以不跟单位
    - 1.5是当前元素文字大小font-size的1.5倍
      * body行高1.5，这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高
### 3. 优先级
  + 选择器相同，则执行层叠性
  + 选择器不同，则根据选择器权重执行
    - 继承/\*（0,0,0,0）< 元素选择器（0,0,0,1）< 类/伪类选择器（0,0,1,0）< ID选择器（0,1,0,0）< 行内样式（1,0,0,0）< !important（∞）
      * 权重是由4组数字组成，但是不会有进位
      * 等级判断从左向右，如果某一位数值相同，则判断下一位数值                                                                                                              
      * 继承的权重是0，如果该元素没有直接选中，不管父元素权重多高，子元素得到的的权重都是0
    - 权重叠加
      * 如果是复合选择器，则会有权重叠加，需要计算权重
      * 权重虽然会叠加，但是永远不会有进位                                                                                                              
## 九、盒子模型
  + css盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距和实际内容
### 1. 边框（border）
  + `border-width`：边框宽度，一般情况下都用px
  + `border-style`：边框样式
    - solid（实线）
    - dashed（虚线）
    - dotted（点线）                                                                                                 
  + `border-color`：边框颜色                                                                                                 
  + 复合写法
     - `border: 1px solid red` 没有顺序                                                                                                    
  + 分开写法
  + 表格的细线边框
    - `border-collapse`：控制浏览器绘制表格边框的方式。它控制相邻单元格的边框
      * collapse（合并相邻的边框）               
  + 边框会额外增加盒子的实际大小                                                                                                  
    - 测量盒子大小的时候，不量边框
    - 如果测量的时候包含了边框，则需要width/height减去边框宽度                                                                                                 
### 2. 内边距（padding）
  + 边框与内容之间的距离                                                                                                  
  + `padding-left/right/top/bottom`                                                                                                  
  + 复合写法 `padding:` 
    - 1个值，代表上下左右的内边距
    - 2个值，代表上下内边距，左右内边距
    - 3个值，代表上内边距，左右内边距，下内边距
    - 4个值，代表上，右，下，左（顺时针）
  + 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子
    - 让width/height减去多出来的内边距大小即可
  + 如果盒子本身没有指定width/height属性，则此时padding不会撑开盒子大小 
### 3. 外边距（margin）
  + 控制盒子和盒子之间的距离                                                                                                  
  + `margin-left/right/top/bottom`                                               
  + 复合写法                                                                                         
  + 外边距可以让**块级**盒子**水平居中**
    - 盒子必须指定了宽度                                                                                                
    - 盒子左右的外边距都设置为auto                                                                                                
    - `margin: 0 auto;`                                                                                                
  + 以上方法是让块级元素水平居中，**行内**元素或者**行内块**元素水平居中给其父元素添加`text-align:center`即可
  + 外边距合并
    - 使用margin定义块元素的垂直外边距时，可能会出现外边距的合并
    - 相邻块元素垂直外边距的合并
      * 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是两者之和，而是**取两个值中的较大者**
    - 嵌套块元素垂直外边距的塌陷
      * 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时**父元素会塌陷较大的外边距值**
      * 解决方案：
        ①可以为父元素定义上边框； ②可以为父元素定义上内边距； ③可以为父元素添加 overflow: hidden； ④浮动、固定、绝对定位的盒子不会有塌陷问题                                                 + 清除内外边距                                         
    - 网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距
      ```
      * {
        padding: 0;
        margin: 0;                                                                                              
      }                                                                                                
      ``` 
    - 行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块级元素就可以了    
                                                                                                    
 ### 4. 圆角边框
   + `border-radius`：外边框圆角
     - （椭）圆与边框的交集形成圆角效果
     - 参数值可以为数值或百分比的形式
     - 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角（顺时针）
     - 分开写：border-top-left-radius、 border-top-right-radius、 border-bottom-right-radius、 border-bottom-left-radius
 ### 5. 盒子阴影
  + `box-shadow: h-shadow v-shadow blur spread color inset;` 
    - h-shadow：必需。水平阴影的位置。允许负值
    - v-shadow：必需。垂直阴影的位置。允许负值  
    - blur：可选。模糊距离
    - spread：可选。阴影的尺寸
    - color：可选。阴影的颜色
    - inset：可选。将外部阴影改为内部阴影
      * 默认的是外阴影（outset），但是不可以写这个单词，否则导致阴影无效
  + 盒子阴影不占用空间，不会影响其他盒子排列                                                                                              
### 6. 文字阴影
  + `text-shadow: h-shadow v-shadow blur color;`

## 十、浮动
CSS提供了三种传统布局方式：
+ 普通流（标准流/文档流）
  - 标签按照规定好默认方式排列
    * 块级元素会独占一行，从上到下顺序排列
      + 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table
    * 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行
      + 常见元素：span、a、i、em等                                                                                              
+ 浮动
  - 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式
  - 最典型的应用：可以让多个块级元素一行内排列显示
  - 多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动                                                                                                  
+ 定位
                                                                                                    
### 1. 什么是浮动
  + float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘
    - none：不浮动（默认值）
    - left：向左浮动
    - right：向右浮动                                                                                                  
### 2. 浮动特性
  + 浮动元素会脱离标准流（脱标）
    - 脱离标准普通流的控制（浮）移动到指定位置（动），（俗称脱标）
    - 浮动的盒子不再保留原先的位置                                                                                                
  + 浮动的元素会一行内显示并且元素顶部对齐
    - 如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐                                                                                                
  + 浮动的元素会具有行内块元素的特性                                                                                                  
    - 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性
      * 如果行内元素有了浮动，则不需要转换为块级/行内块元素就可以直接给高度和宽度
      * 如果块级元素没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定                                                                                          
### 3. 浮动元素经常和标准流父级搭配使用
  + 为了约束浮动元素位置，我们网页布局一般采取的策略是：先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置
  + 先设置盒子大小，之后再设置盒子的位置                                                                                                  
  + 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流
  + 一浮全浮                                                                                                  
### 4. 清除浮动
  + 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子
  + 清除浮动的本质是清除浮动元素造成的影响
    - 如果父盒子本身有高度，则不需要清除浮动                                                                                                
    - 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 
  + `clear:`
    - left：不允许左侧有浮动元素（清除左侧浮动的影响）
    - right：不允许右侧有浮动元素（清除右侧浮动的影响）   
    - both：同时清除左右两侧浮动的影响
  + 清除浮动的策略是：闭合浮动。只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子
  + 清除浮动方法：
    - 额外标签法/隔墙法
      * 在浮动元素末尾添加一个空的标签，例如 <div style=" clear: both "></div> 或者 <br/>
      * 新的空标签必须是块级元素
    - 父级添加overflow方法
      * `overflow: hidden/auto/scroll;`
    - 父级添加:after伪元素
      ```
      .clearfix:after {
        content: '';
        display: block;
        height: 0;
        clear: both;
        visibility: hidden;
      }
      .clearfix {
        /* IE6、7专有 */
        *zoom: 1;    
      }
      ```
    - 父级添加双伪元素                                                                                                
      ```
      .clearfix:before,.clearfix:after {
        content: '';
        display: table;
      }
      .clearfix:after {
        clear: both;
      }
      .clearfix {
        *zoom: 1;    
      }
      ```                                                                                                   
### 5. 案例
  + 导航栏
    - 用li包含链接（li+a）的做法
      * 让导航栏一行显示，给li加浮动，因为li是块级元素，需要一行显示
      * 导航栏可以不给宽度，将来可以继续添加剩余文字
      * 因为导航栏里面文字不一样多，所以最好给链接a左右padding撑开盒子，而不是指定宽度
  +                                                                                                   

## 十一、定位
### 1. 为什么需要定位
  + 定位则是可以让盒子自由地在某个盒子内移动位置或者固定在屏幕中某个位置，并且可以压住其他盒子
### 2. 定位组成
  + 定位 = 定位模式 + 边偏移
    - 定位模式用于指定一个元素在文档中的定位方式
    - 边偏移决定了该元素的最终位置
  + 定位模式
    - `position`
      * static（静态定位）
      * relative（相对定位）
      * absolute（绝对定位）
      * fixed（固定定位）
